# 乐谱编辑页面重构设计文档

## 1. 引言

当前乐谱编辑页面在处理乐符的选择、删除和插入时存在混乱，主要原因是数据结构与页面操作耦合度高，且左右手、小节、小节内乐符的存储设计不合理。本设计文档旨在提出一种重构方案，将页面操作与数据结构分离，优化数据存储设计，以提高系统的可维护性、可扩展性和用户体验。

## 2. 目标

*   **数据模型清晰化**：设计清晰、层次分明的乐谱数据结构，能够准确表达左右手、小节、乐符等概念。
*   **页面操作与数据解耦**：将乐谱编辑的UI操作与底层数据逻辑完全分离，页面仅通过定义好的接口与数据层交互。
*   **提升操作稳定性**：在选择、删除和插入乐符时，避免出现混乱和意外行为。
*   **提高可维护性和可扩展性**：使未来功能扩展和问题修复更加容易。

## 3. 现有功能分析

通过对 `professional_jianpu_editor.dart` 及其相关文件的分析，现有编辑页面主要功能如下：

*   **多轨道编辑**：支持钢琴大谱表的左右手编辑，用户可以通过轨道选择器切换编辑轨道。
*   **音符输入**：提供简谱键盘 (1-7, 0休止符)，用户可选择时值、附点、升降号和八度进行音符输入。
*   **多音模式 (和弦)**：支持在同一拍内输入多个音符形成和弦。
*   **乐符选择**：用户可以点击单个乐符进行选择，选中的乐符会高亮显示。
*   **乐符删除**：在“删除”模式下，点击选中的乐符可以将其删除。
*   **乐符插入**：在小节内部音符之间或小节开始处有“插入区域”，点击后可在此处插入新音符。
*   **小节管理**：显示小节编号，支持小节的选中状态。
*   **撤销/重做**：提供基本的撤销和重做功能。
*   **乐谱元信息**：显示乐谱标题、作曲家、调号、拍号、速度等信息。
*   **歌词输入**：支持为选中的音符添加歌词。
*   **播放高亮**：在播放乐谱时，当前正在播放的音符会高亮显示。
*   **响应式设计**：适应不同屏幕尺寸，提供移动端和桌面端不同的布局。

## 4. 现有问题分析

*   **数据结构与UI耦合**：通过 `JianpuView` 和 `JianpuMeasure` 等模型，UI层似乎直接操作或高度依赖于底层数据结构的具体实现，这使得数据变更和UI更新紧密耦合，难以独立维护和测试。
*   **左右手处理机制**：虽然有 `Track` 和 `Hand`，但在乐符的存储和操作中，左右手的区分和管理可能不够健壮，容易导致乐符混淆。
*   **小节内乐符存储**：音符在小节内的存储和定位似乎是基于 `beat.index` 和 `noteIndexInBeat`，这种基于索引的方案在频繁的插入、删除操作时容易出现索引错位，导致混乱。尤其是在处理和弦（多音）时，复杂度会更高。
*   **选择和操作逻辑**：乐符的选择、删除和插入逻辑直接在UI组件（`_buildProfessionalNote`、`_buildInsertArea`）中处理，并直接调用 `controller` 的方法，缺乏统一的领域逻辑层来保证数据操作的原子性和一致性。
*   **撤销/重做实现**：现有的撤销/重做可能仅停留在简单的状态快照或命令模式，对于复杂乐谱操作的细粒度撤销可能不够完善。

## 5. 设计方案

我们将严格遵循 `CONTRIBUTING.md` 中提到的三层架构（Presentation, Domain, Data），并进一步明确各层的职责，特别是加强领域层作为核心业务逻辑中心的地位。

### 5.1. 架构分层

*   **Presentation (UI层)**:
    *   **职责**：负责乐谱的渲染，接收用户输入（点击、拖拽、键盘事件等），并将用户操作转换为数据层可理解的“意图”。
    *   **实现**：Flutter Widgets (例如 `ProfessionalJianpuEditor`)，以及用于管理UI状态和将事件转发给领域层的 Controller (例如 `SheetEditorController`，但其职责需调整，不再直接操作业务数据)。UI层只订阅领域层提供的数据流，并根据数据变化更新视图。

*   **Domain (领域层)**:
    *   **职责**：核心业务逻辑层。定义乐谱的抽象数据模型，提供对乐谱数据进行操作的接口（例如：添加乐符、删除乐符、选择范围、小节操作）。负责处理乐谱的业务规则、验证和复杂逻辑。所有业务操作（如乐符插入位置计算、和弦合并、撤销重做管理）都在此层完成。
    *   **实现**：`SheetMusicManager` (或类似名称) 服务，`SheetMusic` 模型，`Measure` 模型，`Note` 模型，`Command` (用于撤销/重做) 等。

*   **Data (数据层)**:
    *   **职责**：负责乐谱数据的持久化和加载（例如：从JSON文件加载，保存到本地存储）。不包含任何业务逻辑，仅提供数据存取服务。
    *   **实现**：`SheetMusicRepository` (或类似名称)，`LocalPersistenceService` 等。

### 5.2. 核心数据结构设计 (Domain Layer)

为了解决现有问题，我们将重新设计核心数据结构，使其更加清晰、健壮，并支持左右手、小节、乐符的精细化管理。我们将引入全局唯一ID来标识每个实体。

#### 5.2.1. `SheetMusic` (乐谱)

表示整首乐谱。

```dart
// lib/domain/models/sheet_music.dart
import 'package:uuid/uuid.dart'; // 引入 UUID 生成器
// import 'package:musiclab/shared/enums/enums.dart'; // 假设这里有 MusicKey 和 TimeSignature 枚举

enum MusicKey { C, G, D, A, E, B, Fs, F, Bb, Eb, Ab, Db, Am, Em, Dm }
class TimeSignature {
  final int numerator;
  final int denominator;
  const TimeSignature({required this.numerator, required this.denominator});
}


class SheetMusic {
  final String id;
  String title;
  String? composer;
  MusicKey key; // 调号
  TimeSignature timeSignature; // 拍号
  int tempo; // 速度 (BPM)
  List<Track> tracks; // 乐谱包含的轨道列表

  SheetMusic({
    String? id,
    this.title = 'Untitled',
    this.composer,
    this.key = MusicKey.C, // 默认C调
    this.timeSignature = const TimeSignature(numerator: 4, denominator: 4), // 默认4/4拍
    this.tempo = 60,
    required this.tracks,
  }) : id = id ?? const Uuid().v4();

  // Immutable copyWith 方法，方便在状态更新时创建新实例
  SheetMusic copyWith({
    String? title,
    String? composer,
    MusicKey? key,
    TimeSignature? timeSignature,
    int? tempo,
    List<Track>? tracks,
  }) {
    return SheetMusic(
      id: id,
      title: title ?? this.title,
      composer: composer ?? this.composer,
      key: key ?? this.key,
      timeSignature: timeSignature ?? this.timeSignature,
      tempo: tempo ?? this.tempo,
      tracks: tracks ?? this.tracks,
    );
  }
}
```

#### 5.2.2. `Track` (轨道)

表示乐谱中的一个独立声部，用于区分左右手。

```dart
// lib/domain/models/track.dart
import 'package:uuid/uuid.dart';

enum Hand {
  left,
  right,
}

class Track {
  final String id;
  Hand hand; // 区分左右手
  String name; // 轨道名称，如“左手”、“右手”
  List<Measure> measures; // 轨道包含的小节列表

  Track({
    String? id,
    required this.hand,
    required this.name,
    required this.measures,
  }) : id = id ?? const Uuid().v4();

  Track copyWith({
    Hand? hand,
    String? name,
    List<Measure>? measures,
  }) {
    return Track(
      id: id,
      hand: hand ?? this.hand,
      name: name ?? this.name,
      measures: measures ?? this.measures,
    );
  }
}
```

#### 5.2.3. `Measure` (小节)

表示乐谱中的一个小节。为了解决现有“小节内乐符存储”的问题，我们将不再直接使用 `Beat` 模型来嵌套 `Note`，而是让 `Measure` 直接管理其内部的 `Note` 列表，并通过 `startTimeInMeasure` 属性来定位音符。这样可以更好地支持和弦和不同时值的音符。

```dart
// lib/domain/models/measure.dart
import 'package:uuid/uuid.dart';

class Measure {
  final String id;
  int measureNumber; // 小节编号 (从1开始)
  List<Note> notes; // 小节内的乐符列表，按 startTimeInMeasure 排序

  Measure({
    String? id,
    required this.measureNumber,
    required this.notes,
  }) : id = id ?? const Uuid().v4();

  Measure copyWith({
    int? measureNumber,
    List<Note>? notes,
  }) {
    return Measure(
      id: id,
      measureNumber: measureNumber ?? this.measureNumber,
      notes: notes ?? this.notes,
    );
  }
}
```

#### 5.2.4. `Note` (乐符)

表示单个乐符。

```dart
// lib/domain/models/note.dart
import 'package:uuid/uuid.dart';
// import 'package:musiclab/shared/enums/enums.dart'; // 假设这里有 Accidental 枚举
enum Accidental { none, sharp, flat }

enum DurationType {
  whole,      // 全音符
  half,       // 二分音符
  quarter,    // 四分音符
  eighth,     // 八分音符
  sixteenth,  // 十六分音符
  thirtySecond, // 三十二分音符
}

class Note {
  final String id;
  int midiPitch; // MIDI 音高 (0-127)，包含八度、升降号
  DurationType durationType; // 时值类型
  double startTimeInMeasure; // 在小节内的起始时间 (相对于小节开始，单位为拍，例如 4/4 拍的小节，每个拍是 1.0)
  bool isRest; // 是否休止符
  bool isDotted; // 是否附点
  String? lyric; // 歌词

  // 辅助属性，用于UI显示，不存储到数据中
  // int get octaveOffset; // 从 midiPitch 计算
  // Accidental get accidental; // 从 midiPitch 计算

  Note({
    String? id,
    required this.midiPitch,
    required this.durationType,
    required this.startTimeInMeasure,
    this.isRest = false,
    this.isDotted = false,
    this.lyric,
  }) : id = id ?? const Uuid().v4();

  // 根据 MIDI Pitch 计算音高等级 (1-7) 和八度偏移
  // 这部分逻辑可以放在一个独立的工具类或扩展方法中
  // 假设 C4 为 MIDI 60
  int getDegree(MusicKey key) {
    // 根据调号和 MIDI pitch 计算简谱的度数
    // ...
    return 1; // 示例
  }

  int getOctaveOffset(MusicKey key) {
    // 根据调号和 MIDI pitch 计算八度偏移
    // ...
    return 0; // 示例
  }

  Accidental getAccidental(MusicKey key) {
    // 根据调号和 MIDI pitch 计算变音记号
    // ...
    return Accidental.none; // 示例
  }

  Note copyWith({
    int? midiPitch,
    DurationType? durationType,
    double? startTimeInMeasure,
    bool? isRest,
    bool? isDotted,
    String? lyric,
  }) {
    return Note(
      id: id,
      midiPitch: midiPitch ?? this.midiPitch,
      durationType: durationType ?? this.durationType,
      startTimeInMeasure: startTimeInMeasure ?? this.startTimeInMeasure,
      isRest: isRest ?? this.isRest,
      isDotted: isDotted ?? this.isDotted,
      lyric: lyric ?? this.lyric,
    );
  }
}
```

#### 5.2.5. 辅助模型

*   **`SelectedNote` (选中乐符)**：用于表示UI上选中的单个乐符。

```dart
// lib/domain/models/selected_note.dart
class SelectedNote {
  final String noteId;
  final String measureId;
  final String trackId;

  SelectedNote({
    required this.noteId,
    required this.measureId,
    required this.trackId,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SelectedNote &&
          runtimeType == other.runtimeType &&
          noteId == other.noteId &&
          measureId == other.measureId &&
          trackId == other.trackId;

  @override
  int get hashCode => noteId.hashCode ^ measureId.hashCode ^ trackId.hashCode;
}
```

#### 5.2.6. 与现有模型的整合和替换

*   **`Score` 替换为 `SheetMusic`**：`SheetMusic` 将成为新的顶级乐谱数据模型。
*   **`Track` 沿用**：现有 `Track` 模型可以直接整合到新的设计中，只需确保其包含 `Measure` 列表。
*   **`JianpuMeasure` 和 `JianpuNote` 替换为 `Measure` 和 `Note`**：简化模型层次，避免UI渲染模型与领域模型混淆。所有UI展示所需的数据都应从 `Measure` 和 `Note` 中派生。
*   **`Beat` 模型移除**：通过 `Note` 中的 `startTimeInMeasure` 直接定位音符，简化小节内部的结构管理，更好地支持和弦和不同时值的音符排列。和弦将表现为多个 `Note` 对象拥有相同的 `startTimeInMeasure`。

### 5.3. 领域层操作接口设计 (`SheetMusicManager`)

`SheetMusicManager` 是领域层的核心服务，它将封装所有乐谱相关的业务逻辑，并提供一个清晰的接口供UI层调用。所有的乐谱数据操作都将通过 `SheetMusicManager` 进行，以确保数据的一致性和业务规则的正确性。

```dart
// lib/domain/services/sheet_music_manager.dart
import 'dart:async';
import 'package:get/get.dart'; // 使用 GetX 进行状态管理和依赖注入

import '../models/sheet_music.dart';
import '../models/track.dart';
import '../models/note.dart';
import '../models/selected_note.dart';
// import '../repositories/sheet_music_repository.dart'; // 假设有这个仓库

// 定义一个虚假的 SheetMusicRepository，用于设计
class SheetMusicRepository {
  Future<SheetMusic> loadSheetMusic(String sheetId) async {
    // 模拟从数据源加载乐谱
    await Future.delayed(const Duration(milliseconds: 100));
    final track = Track(hand: Hand.right, name: '右手', measures: [
      Measure(measureNumber: 1, notes: [
        Note(midiPitch: 60, durationType: DurationType.quarter, startTimeInMeasure: 0.0),
        Note(midiPitch: 62, durationType: DurationType.quarter, startTimeInMeasure: 1.0),
      ]),
      Measure(measureNumber: 2, notes: [
        Note(midiPitch: 64, durationType: DurationType.quarter, startTimeInMeasure: 0.0),
      ]),
    ]);
    return SheetMusic(id: sheetId, title: '测试乐谱', tracks: [track]);
  }

  Future<void> saveSheetMusic(SheetMusic sheetMusic) async {
    // 模拟保存乐谱到数据源
    await Future.delayed(const Duration(milliseconds: 100));
    print('乐谱已保存: ${sheetMusic.title}');
  }
}


class SheetMusicManager extends GetxController {
  final SheetMusicRepository _repository; // 注入数据仓库

  // Rx 变量用于存储当前的乐谱状态，UI层可以订阅这个流
  final Rx<SheetMusic?> _currentSheetMusic = Rx<SheetMusic?>(null);
  SheetMusic? get currentSheetMusic => _currentSheetMusic.value;

  // 选中状态
  final Rx<SelectedNote?> _selectedNote = Rx<SelectedNote?>(null);
  SelectedNote? get selectedNote => _selectedNote.value;

  final RxList<SelectedNote> _multiSelectedNotes = RxList<SelectedNote>(); // 支持多选
  List<SelectedNote> get multiSelectedNotes => _multiSelectedNotes.toList();

  final RxString _selectedTrackId = RxString(''); // 当前选中的轨道ID
  String get selectedTrackId => _selectedTrackId.value;

  // 撤销/重做相关
  final RxBool _canUndo = false.obs;
  bool get canUndo => _canUndo.value;
  final RxBool _canRedo = false.obs;
  bool get canRedo => _canRedo.value;

  // 存储操作历史的栈，用于撤销/重做
  final List<SheetMusic> _history = [];
  int _historyIndex = -1;

  SheetMusicManager({required SheetMusicRepository repository}) : _repository = repository;

  @override
  void onInit() {
    super.onInit();
    // 可以在这里加载默认乐谱或执行初始化操作
  }

  /// 加载乐谱
  Future<void> loadSheetMusic(String sheetId) async {
    final sheet = await _repository.loadSheetMusic(sheetId);
    _currentSheetMusic.value = sheet;
    _clearHistory(); // 加载新乐谱时清空历史
    _saveCurrentStateToHistory(); // 将初始状态保存到历史
  }

  /// 创建新乐谱
  void createNewSheetMusic({String? title, Hand initialHand = Hand.right}) {
    final newTrack = Track(hand: initialHand, name: initialHand == Hand.right ? '右手' : '左手', measures: [
      Measure(measureNumber: 1, notes: []),
    ]);
    final newSheet = SheetMusic(
      title: title ?? '新乐谱',
      tracks: [newTrack],
    );
    _currentSheetMusic.value = newSheet;
    _clearHistory();
    _saveCurrentStateToHistory();
    _selectedTrackId.value = newTrack.id; // 默认选中第一个轨道
    _selectedNote.value = null;
    _multiSelectedNotes.clear();
  }

  /// 保存乐谱
  Future<void> saveCurrentSheetMusic() async {
    if (_currentSheetMusic.value != null) {
      await _repository.saveSheetMusic(_currentSheetMusic.value!);
    }
  }

  // MARK: - 乐谱元信息操作

  void updateSheetTitle(String title) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(title: title);
      });
    }
  }

  void updateSheetComposer(String composer) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(composer: composer);
      });
    }
  }

  void updateSheetKey(MusicKey key) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(key: key);
      });
    }
  }

  void updateSheetTimeSignature(TimeSignature timeSignature) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(timeSignature: timeSignature);
      });
    }
  }

  void updateSheetTempo(int tempo) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(tempo: tempo);
      });
    }
  }

  // MARK: - 轨道操作

  void selectTrack(String trackId) {
    _selectedTrackId.value = trackId;
    _selectedNote.value = null; // 切换轨道时清除单选
    _multiSelectedNotes.clear(); // 切换轨道时清除多选
  }

  /// 添加一个新轨道
  void addTrack(Hand hand, String name) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        final newTrack = Track(hand: hand, name: name, measures: [Measure(measureNumber: 1, notes: [])]);
        final updatedTracks = List<Track>.from(_currentSheetMusic.value!.tracks)..add(newTrack);
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(tracks: updatedTracks);
        _selectedTrackId.value = newTrack.id; // 默认选中新轨道
      });
    }
  }

  /// 删除指定轨道
  void deleteTrack(String trackId) {
    if (_currentSheetMusic.value != null && _currentSheetMusic.value!.tracks.length > 1) {
      _executeCommand(() {
        final updatedTracks = _currentSheetMusic.value!.tracks.where((t) => t.id != trackId).toList();
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(tracks: updatedTracks);
        if (_selectedTrackId.value == trackId) {
          _selectedTrackId.value = updatedTracks.first.id; // 选中剩余的第一个轨道
        }
      });
    }
  }

  // MARK: - 小节操作

  /// 在指定轨道和位置添加一个小节
  void addMeasure(String trackId, int atIndex) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        final updatedTracks = _currentSheetMusic.value!.tracks.map((track) {
          if (track.id == trackId) {
            final newMeasure = Measure(measureNumber: atIndex + 1, notes: []);
            final updatedMeasures = List<Measure>.from(track.measures);
            updatedMeasures.insert(atIndex, newMeasure);
            // 重新编号所有小节
            for (int i = 0; i < updatedMeasures.length; i++) {
              updatedMeasures[i] = updatedMeasures[i].copyWith(measureNumber: i + 1);
            }
            return track.copyWith(measures: updatedMeasures);
          }
          return track;
        }).toList();
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(tracks: updatedTracks);
      });
    }
  }

  /// 删除指定轨道和ID的小节
  void deleteMeasure(String trackId, String measureId) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        final updatedTracks = _currentSheetMusic.value!.tracks.map((track) {
          if (track.id == trackId) {
            final updatedMeasures = track.measures.where((m) => m.id != measureId).toList();
            // 重新编号所有小节
            for (int i = 0; i < updatedMeasures.length; i++) {
              updatedMeasures[i] = updatedMeasures[i].copyWith(measureNumber: i + 1);
            }
            return track.copyWith(measures: updatedMeasures);
          }
          return track;
        }).toList();
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(tracks: updatedTracks);
        _selectedNote.value = null; // 删除小节时清除选中
        _multiSelectedNotes.clear();
      });
    }
  }

  /// 分割小节
  /// [measureId] 要分割的小节ID
  /// [splitTime] 分割点，相对于小节开始的拍数
  void splitMeasure(String trackId, String measureId, double splitTime) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        final updatedTracks = _currentSheetMusic.value!.tracks.map((track) {
          if (track.id == trackId) {
            final measureIndex = track.measures.indexWhere((m) => m.id == measureId);
            if (measureIndex != -1) {
              final originalMeasure = track.measures[measureIndex];
              final notesBeforeSplit = originalMeasure.notes.where((note) => note.startTimeInMeasure < splitTime).toList();
              final notesAfterSplit = originalMeasure.notes.where((note) => note.startTimeInMeasure >= splitTime).toList();

              final newMeasure1 = originalMeasure.copyWith(notes: notesBeforeSplit);
              final newMeasure2 = Measure(measureNumber: originalMeasure.measureNumber + 1, notes: notesAfterSplit);

              final updatedMeasures = List<Measure>.from(track.measures);
              updatedMeasures
                ..removeAt(measureIndex)
                ..insert(measureIndex, newMeasure1)
                ..insert(measureIndex + 1, newMeasure2);

              // 重新编号所有小节
              for (int i = 0; i < updatedMeasures.length; i++) {
                updatedMeasures[i] = updatedMeasures[i].copyWith(measureNumber: i + 1);
              }
              return track.copyWith(measures: updatedMeasures);
            }
          }
          return track;
        }).toList();
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(tracks: updatedTracks);
      });
    }
  }

  /// 合并小节
  /// [measureIds] 要合并的小节ID列表，按顺序
  void mergeMeasures(String trackId, List<String> measureIds) {
    if (measureIds.length < 2) return; // 至少需要两个小节才能合并

    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        final updatedTracks = _currentSheetMusic.value!.tracks.map((track) {
          if (track.id == trackId) {
            final measuresToMerge = measureIds.map((id) => track.measures.firstWhere((m) => m.id == id)).toList();
            measuresToMerge.sort((a, b) => a.measureNumber.compareTo(b.measureNumber)); // 确保按顺序合并

            final mergedNotes = <Note>[];
            double currentTimeInMeasure = 0.0; // 合并后新小节的当前时间

            for (final measure in measuresToMerge) {
              final timeSignature = _currentSheetMusic.value!.timeSignature; // 假设所有小节拍号一致
              // 此处需要注意，如果合并的小节拍号不同，处理逻辑会更复杂
              // 简谱通常在一个乐谱中拍号保持一致，因此这里暂时简化
              final beatsPerMeasure = timeSignature.numerator / timeSignature.denominator; // 例如 4/4 拍是 4.0

              for (final note in measure.notes) {
                // 将原小节内的起始时间转换为合并后的新小节内的起始时间
                mergedNotes.add(note.copyWith(startTimeInMeasure: note.startTimeInMeasure + currentTimeInMeasure));
              }
              currentTimeInMeasure += beatsPerMeasure; // 累加每个小节的时长
            }

            final firstMeasureNumber = measuresToMerge.first.measureNumber;
            final newMergedMeasure = Measure(
              measureNumber: firstMeasureNumber,
              notes: mergedNotes,
            );

            final updatedMeasures = List<Measure>.from(track.measures);
            // 移除被合并的小节
            updatedMeasures.removeWhere((m) => measureIds.contains(m.id));
            // 插入新的合并小节
            final insertIndex = updatedMeasures.indexWhere((m) => m.measureNumber >= firstMeasureNumber);
            if (insertIndex != -1) {
              updatedMeasures.insert(insertIndex, newMergedMeasure);
            } else {
              updatedMeasures.add(newMergedMeasure);
            }

            // 重新编号所有小节
            for (int i = 0; i < updatedMeasures.length; i++) {
              updatedMeasures[i] = updatedMeasures[i].copyWith(measureNumber: i + 1);
            }
            return track.copyWith(measures: updatedMeasures);
          }
          return track;
        }).toList();
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(tracks: updatedTracks);
        _selectedNote.value = null; // 合并小节时清除选中
        _multiSelectedNotes.clear();
      });
    }
  }


  // MARK: - 乐符操作

  /// 在指定轨道、小节和起始时间插入乐符
  /// [trackId] 目标轨道ID
  /// [measureId] 目标小节ID
  /// [startTime] 在小节内的起始时间（拍数）
  /// [midiPitch] MIDI音高
  /// [durationType] 时值类型
  /// [isRest] 是否休止符
  /// [isDotted] 是否附点
  void addNote(
    String trackId,
    String measureId,
    double startTime,
    int midiPitch,
    DurationType durationType, {
    bool isRest = false,
    bool isDotted = false,
    String? lyric,
  }) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        final newNote = Note(
          midiPitch: midiPitch,
          durationType: durationType,
          startTimeInMeasure: startTime,
          isRest: isRest,
          isDotted: isDotted,
          lyric: lyric,
        );

        final updatedTracks = _currentSheetMusic.value!.tracks.map((track) {
          if (track.id == trackId) {
            final updatedMeasures = track.measures.map((measure) {
              if (measure.id == measureId) {
                final newNotes = List<Note>.from(measure.notes)..add(newNote);
                // 插入后按 startTimeInMeasure 排序
                newNotes.sort((a, b) => a.startTimeInMeasure.compareTo(b.startTimeInMeasure));
                return measure.copyWith(notes: newNotes);
              }
              return measure;
            }).toList();
            return track.copyWith(measures: updatedMeasures);
          }
          return track;
        }).toList();
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(tracks: updatedTracks);

        // 选中新添加的音符
        _selectedNote.value = SelectedNote(noteId: newNote.id, measureId: measureId, trackId: trackId);
        _multiSelectedNotes.clear();
      });
    }
  }

  /// 添加和弦 (多个音符在同一拍)
  void addChord(
    String trackId,
    String measureId,
    double startTime,
    List<int> midiPitches, // 多个音高
    DurationType durationType, {
    bool isDotted = false,
    String? lyric,
  }) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        final newNotes = midiPitches.map((pitch) => Note(
              midiPitch: pitch,
              durationType: durationType,
              startTimeInMeasure: startTime,
              isDotted: isDotted,
              lyric: lyric,
            )).toList();

        final updatedTracks = _currentSheetMusic.value!.tracks.map((track) {
          if (track.id == trackId) {
            final updatedMeasures = track.measures.map((measure) {
              if (measure.id == measureId) {
                final currentNotes = List<Note>.from(measure.notes);
                currentNotes.addAll(newNotes);
                currentNotes.sort((a, b) => a.startTimeInMeasure.compareTo(b.startTimeInMeasure));
                return measure.copyWith(notes: currentNotes);
              }
              return measure;
            }).toList();
            return track.copyWith(measures: updatedMeasures);
          }
          return track;
        }).toList();
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(tracks: updatedTracks);

        // 选中新添加的和弦中的第一个音符，或者全部多选
        if (newNotes.isNotEmpty) {
           _multiSelectedNotes.value = newNotes.map((n) => SelectedNote(noteId: n.id, measureId: measureId, trackId: trackId)).toList().obs;
           _selectedNote.value = _multiSelectedNotes.first;
        } else {
          _selectedNote.value = null;
          _multiSelectedNotes.clear();
        }
      });
    }
  }


  /// 删除指定ID的乐符 (支持删除多选)
  void deleteNotes(List<String> noteIdsToDelete) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        final updatedTracks = _currentSheetMusic.value!.tracks.map((track) {
          final updatedMeasures = track.measures.map((measure) {
            final updatedNotes = measure.notes.where((note) => !noteIdsToDelete.contains(note.id)).toList();
            return measure.copyWith(notes: updatedNotes);
          }).toList();
          return track.copyWith(measures: updatedMeasures);
        }).toList();
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(tracks: updatedTracks);
        _selectedNote.value = null; // 清除选中
        _multiSelectedNotes.clear();
      });
    }
  }

  /// 删除当前选中的音符 (单选或多选)
  void deleteSelectedNotes() {
    if (_selectedNote.value != null) {
      deleteNotes([_selectedNote.value!.noteId]);
    } else if (_multiSelectedNotes.isNotEmpty) {
      deleteNotes(_multiSelectedNotes.map((s) => s.noteId).toList());
    }
  }

  /// 更新乐符属性
  void updateNote(String noteId, String measureId, String trackId, {
    int? midiPitch,
    DurationType? durationType,
    double? startTimeInMeasure,
    bool? isRest,
    bool? isDotted,
    String? lyric,
  }) {
    if (_currentSheetMusic.value != null) {
      _executeCommand(() {
        final updatedTracks = _currentSheetMusic.value!.tracks.map((track) {
          if (track.id == trackId) {
            final updatedMeasures = track.measures.map((measure) {
              if (measure.id == measureId) {
                final updatedNotes = measure.notes.map((note) {
                  if (note.id == noteId) {
                    return note.copyWith(
                      midiPitch: midiPitch,
                      durationType: durationType,
                      startTimeInMeasure: startTimeInMeasure,
                      isRest: isRest,
                      isDotted: isDotted,
                      lyric: lyric,
                    );
                  }
                  return note;
                }).toList();
                updatedNotes.sort((a, b) => a.startTimeInMeasure.compareTo(b.startTimeInMeasure)); // 确保排序
                return measure.copyWith(notes: updatedNotes);
              }
              return measure;
            }).toList();
            return track.copyWith(measures: updatedMeasures);
          }
          return track;
        }).toList();
        _currentSheetMusic.value = _currentSheetMusic.value!.copyWith(tracks: updatedTracks);
      });
    }
  }


  // MARK: - 选中状态管理

  /// 单选一个乐符
  void selectSingleNote(String noteId, String measureId, String trackId) {
    _selectedNote.value = SelectedNote(noteId: noteId, measureId: measureId, trackId: trackId);
    _multiSelectedNotes.clear(); // 清除多选
  }

  /// 切换乐符的多选状态
  void toggleMultiSelectNote(String noteId, String measureId, String trackId) {
    final selected = SelectedNote(noteId: noteId, measureId: measureId, trackId: trackId);
    if (_multiSelectedNotes.contains(selected)) {
      _multiSelectedNotes.remove(selected);
    } else {
      _multiSelectedNotes.add(selected);
    }
    _selectedNote.value = null; // 多选时不使用单选
  }

  /// 清除所有选中状态
  void clearSelection() {
    _selectedNote.value = null;
    _multiSelectedNotes.clear();
  }

  // MARK: - 撤销/重做

  /// 执行一个会改变乐谱状态的命令，并将其保存到历史记录
  void _executeCommand(VoidCallback command) {
    // 移除所有在当前历史点之后的操作，以便进行新的操作
    if (_historyIndex < _history.length - 1) {
      _history.removeRange(_historyIndex + 1, _history.length);
    }

    command(); // 执行命令
    _saveCurrentStateToHistory();
  }

  /// 将当前乐谱状态保存到历史记录
  void _saveCurrentStateToHistory() {
    if (_currentSheetMusic.value != null) {
      // 深度拷贝当前乐谱状态，防止引用问题
      final sheetCopy = _deepCopySheetMusic(_currentSheetMusic.value!);
      _history.add(sheetCopy);
      _historyIndex = _history.length - 1;
      _updateUndoRedoStatus();
    }
  }

  /// 撤销操作
  void undo() {
    if (canUndo) {
      _historyIndex--;
      _currentSheetMusic.value = _deepCopySheetMusic(_history[_historyIndex]);
      _updateUndoRedoStatus();
      _selectedNote.value = null; // 撤销时清除选中
      _multiSelectedNotes.clear();
    }
  }

  /// 重做操作
  void redo() {
    if (canRedo) {
      _historyIndex++;
      _currentSheetMusic.value = _deepCopySheetMusic(_history[_historyIndex]);
      _updateUndoRedoStatus();
      _selectedNote.value = null; // 重做时清除选中
      _multiSelectedNotes.clear();
    }
  }

  /// 更新撤销/重做按钮状态
  void _updateUndoRedoStatus() {
    _canUndo.value = _historyIndex > 0;
    _canRedo.value = _historyIndex < _history.length - 1;
  }

  /// 清空历史记录
  void _clearHistory() {
    _history.clear();
    _historyIndex = -1;
    _updateUndoRedoStatus();
  }

  /// 深度拷贝 SheetMusic 对象及其所有嵌套对象
  SheetMusic _deepCopySheetMusic(SheetMusic original) {
    final copiedTracks = original.tracks.map((track) {
      final copiedMeasures = track.measures.map((measure) {
        final copiedNotes = measure.notes.map((note) => note.copyWith()).toList();
        return measure.copyWith(notes: copiedNotes);
      }).toList();
      return track.copyWith(measures: copiedMeasures);
    }).toList();
    return original.copyWith(tracks: copiedTracks);
  }

  // MARK: - 辅助方法 (可移动到工具类)

  /// 根据 MIDI Pitch 和当前调号获取简谱度数
  int getJianpuDegree(int midiPitch) {
    // 假设 C4 为 MIDI 60 (简谱 1)
    // 根据实际情况调整此逻辑
    final relativePitch = midiPitch - 60; // 相对于C4的半音数
    if (relativePitch == 0) return 1; // C
    if (relativePitch == 2) return 2; // D
    if (relativePitch == 4) return 3; // E
    if (relativePitch == 5) return 4; // F
    if (relativePitch == 7) return 5; // G
    if (relativePitch == 9) return 6; // A
    if (relativePitch == 11) return 7; // B
    // TODO: 处理升降号和八度，需要更复杂的逻辑，这只是一个简化示例
    return 1; // 默认
  }

  /// 根据 MIDI Pitch 和当前调号获取八度偏移
  int getOctaveOffset(int midiPitch) {
    // 假设 C4 为 MIDI 60 (简谱 1，中音)
    // C3 (MIDI 48) 八度偏移为 -1
    // C5 (MIDI 72) 八度偏移为 1
    // (midiPitch - 60) / 12 可以得到一个大致的八度偏移
    // 需要根据具体简谱规则调整
    return ((midiPitch - 60) / 12).round(); // 示例
  }

  /// 根据 MIDI Pitch 获取变音记号
  Accidental getAccidental(int midiPitch) {
    // 根据 MIDI pitch 判断是否存在升降号
    // 例如，MIDI 61 是 C# 或 Db
    final int pitchClass = midiPitch % 12;
    if ([1, 3, 6, 8, 10].contains(pitchClass)) {
      // 简谱通常不直接表示升降号，而是通过音高点或特定符号
      // 这里需要根据简谱的实际表示方式进行转换
      // 暂时返回 Sharp，后续细化
      return Accidental.sharp; // 示例
    }
    return Accidental.none;
  }
}
```

### 5.4. UI层与领域层的交互

UI层 (`Presentation Layer`) 将不再直接修改乐谱数据模型，而是通过 `SheetMusicManager` (`Domain Layer`) 提供的公共接口来发送操作请求，并订阅其暴露的响应式数据流来更新视图。

#### 5.4.1. UI发送操作请求

*   **集中化请求**：所有用户在UI上的操作，如点击音符、点击插入区域、点击键盘音符、切换编辑模式、撤销/重做等，都将通过 `SheetEditorController` 捕获，然后转发给 `SheetMusicManager`。
*   **参数传递**：`SheetEditorController` 负责将UI事件中的必要信息（如点击的乐符ID、小节ID、轨道ID、新的音高、时值等）提取出来，并作为参数传递给 `SheetMusicManager` 相应的操作方法。
*   **避免直接操作模型**：UI组件中不再包含直接修改 `SheetMusic`、`Measure` 或 `Note` 列表的代码。例如，不再有 `measure.notes.add(newNote)` 这样的逻辑。

**示例：**

1.  **用户点击键盘上的“1” (Do)**：
    *   `_buildNoteKey` (在 `ProfessionalJianpuEditor` 中) 的 `onTap` 回调被触发。
    *   该回调将调用 `SheetEditorController` 的 `handleNoteInput` 方法。
    *   `SheetEditorController` 根据当前选中的轨道、小节、插入位置、时值、八度、升降号等UI状态，构造出完整的音符信息。
    *   `SheetEditorController` 调用 `sheetMusicManager.addNote(selectedTrackId, selectedMeasureId, insertTime, midiPitch, durationType, ...)`。
    *   `SheetMusicManager` 处理乐符插入的业务逻辑，更新其内部的 `_currentSheetMusic` 响应式变量。

2.  **用户点击一个已有的乐符进行选择**：
    *   `_buildProfessionalNote` 的 `onTap` 回调被触发。
    *   该回调将调用 `SheetEditorController` 的 `handleNoteSelection` 方法。
    *   `SheetEditorController` 提取出被点击乐符的ID、所在小节ID、所在轨道ID。
    *   `SheetEditorController` 调用 `sheetMusicManager.selectSingleNote(noteId, measureId, trackId)` 或 `sheetMusicManager.toggleMultiSelectNote(...)`。
    *   `SheetMusicManager` 更新其内部的 `_selectedNote` 或 `_multiSelectedNotes` 响应式变量。

3.  **用户点击“撤销”按钮**：
    *   `_buildTopToolbar` 中的 `IconButton` 的 `onPressed` 回调被触发。
    *   直接调用 `sheetMusicManager.undo()`。

#### 5.4.2. UI响应数据变化

*   **订阅响应式数据流**：`ProfessionalJianpuEditor` (及其子Widget) 将使用 `Obx` 或 `GetBuilder` 等 `GetX` 提供的响应式Widget来监听 `SheetMusicManager` 中暴露的响应式数据（`currentSheetMusic`, `selectedNote`, `multiSelectedNotes`, `selectedTrackId`, `canUndo`, `canRedo` 等）。
*   **视图自动更新**：当 `SheetMusicManager` 中的响应式数据发生变化时，所有订阅了这些数据的UI组件会自动重建，反映最新的乐谱状态。
*   **`SheetEditorController` 的职责**：`SheetEditorController` 的职责将变为轻量级的UI状态管理（例如当前编辑模式 `EditorMode`、底部键盘的时值、八度、升降号等），以及将UI事件转发给 `SheetMusicManager`。它不再拥有复杂的乐谱数据操作逻辑。

**示例：**

1.  **乐谱数据更新**：
    *   `ProfessionalJianpuEditor` 中的 `build` 方法通过 `Obx(() => controller.currentScore.value)` (需要将 `currentScore` 绑定到 `sheetMusicManager.currentSheetMusic`) 监听整个乐谱对象。
    *   当 `sheetMusicManager._currentSheetMusic` 发生变化时，整个乐谱编辑区域会根据新的 `SheetMusic` 对象重新渲染。

2.  **选中状态更新**：
    *   `_buildProfessionalNote` Widget中的 `isSelected` 逻辑将通过监听 `sheetMusicManager.selectedNote` 和 `sheetMusicManager.multiSelectedNotes` 来确定当前音符是否被选中，从而更新高亮状态。
    *   例如：`isSelected = sheetMusicManager.selectedNote?.noteId == note.id || sheetMusicManager.multiSelectedNotes.any((s) => s.noteId == note.id);`

3.  **撤销/重做按钮状态更新**：
    *   顶部工具栏的撤销/重做按钮将监听 `sheetMusicManager.canUndo` 和 `sheetMusicManager.canRedo`，以启用或禁用按钮。

#### 5.4.3. 数据流向总结

1.  **用户交互**：UI层捕获用户交互事件 (例如，点击按钮、键盘输入)。
2.  **UI Controller (SheetEditorController)**：UI Controller 接收事件，并根据当前的UI状态（如选中的时值、八度等），将用户意图转化为对领域层服务的调用。
3.  **领域服务 (SheetMusicManager)**：领域服务接收调用，执行业务逻辑（如添加、删除乐符，验证规则，更新数据），并将新的乐谱状态（通过 `copyWith` 创建新对象）发布到其响应式数据流。
4.  **UI层 (Widgets)**：UI层通过 `Obx` 等响应式组件订阅领域服务的数据流。当数据流中的乐谱状态更新时，UI自动重新渲染，展示最新结果。

通过这种严格的分层和单向数据流设计，可以实现UI与数据的高度解耦，提高系统的可维护性、可测试性，并减少因UI直接操作数据而导致的错误。

### 5.5. 乐符的选择、删除和插入逻辑

这一部分是重构的核心，旨在解决现有系统中乐符操作混乱的问题。所有这些操作都将在 `SheetMusicManager` 中实现，UI层只负责触发这些操作并接收结果。

#### 5.5.1. 选择逻辑

*   **单选 (`selectSingleNote`)**：
    *   当用户点击单个乐符时，UI层会将该乐符的 `noteId`, `measureId`, `trackId` 传递给 `selectSingleNote` 方法。
    *   `SheetMusicManager` 将 `_selectedNote` 更新为新的 `SelectedNote` 对象，并清除 `_multiSelectedNotes`。
*   **多选 (`toggleMultiSelectNote`)**：
    *   当用户在选择模式下，按住修饰键（例如 Ctrl/Cmd）点击多个乐符时，UI层会将每个被点击乐符的信息传递给 `toggleMultiSelectNote` 方法。
    *   `SheetMusicManager` 将在 `_multiSelectedNotes` 列表中添加或移除对应的 `SelectedNote`。
    *   如果 `_multiSelectedNotes` 不为空，`_selectedNote` 将被清除，以确保单一选择和多重选择互斥。
*   **范围选择 (Future)**：
    *   如果需要支持拖拽选择区域，UI层将提供起始和结束位置（例如，起始小节ID、起始拍，结束小节ID、结束拍）。
    *   `SheetMusicManager` 将遍历所有受影响的轨道和小节，识别在该区域内的所有乐符，并将它们添加到 `_multiSelectedNotes` 中。
*   **清除选择 (`clearSelection`)**：
    *   UI层调用此方法时，`SheetMusicManager` 将清除 `_selectedNote` 和 `_multiSelectedNotes`。

**关键点**：`SelectedNote` 包含 `noteId`, `measureId`, `trackId`，确保唯一识别，即使乐符在乐谱中移动，只要ID不变，选择状态依然有效。

#### 5.5.2. 删除逻辑

*   **删除单个乐符 (`deleteNotes` with single ID)**：
    *   当用户在删除模式下点击一个已选中的乐符时，UI层将调用 `deleteSelectedNotes` 方法。
    *   `SheetMusicManager` 根据 `_selectedNote.noteId` 找到并删除该乐符。
*   **删除多个乐符 (`deleteNotes` with multiple IDs)**：
    *   当用户选中多个乐符后，执行删除操作时，UI层将调用 `deleteSelectedNotes` 方法。
    *   `SheetMusicManager` 将遍历所有选中的 `_multiSelectedNotes`，批量删除这些乐符。
*   **删除小节 (`deleteMeasure`)**：
    *   当用户选择一个小节并执行删除操作时，UI层将调用 `deleteMeasure(trackId, measureId)`。
    *   `SheetMusicManager` 将从指定轨道中移除该小节，并重新编号后续小节。
*   **删除轨道 (`deleteTrack`)**：
    *   当用户删除一个轨道时，UI层将调用 `deleteTrack(trackId)`。
    *   `SheetMusicManager` 将从 `SheetMusic` 中移除该轨道。

**实现细节**：
*   删除操作将通过创建新的 `SheetMusic`、`Track` 和 `Measure` 实例来实现“删除”，而不是直接修改现有列表，以支持不可变性。
*   删除后，需要清除所有相关的选中状态。

#### 5.5.3. 插入逻辑

*   **插入单个乐符 (`addNote`)**：
    *   当用户在输入模式下，点击插入区域或键盘上的音符时，UI层将调用 `addNote(trackId, measureId, startTime, midiPitch, durationType, ...)`。
    *   `SheetMusicManager` 会在指定轨道和小节内，根据 `startTime` 找到正确的插入位置。
    *   如果同一 `startTime` 已经存在音符，并且不是和弦模式，则可以根据设计选择替换或添加到和弦中。在我们的设计中，如果 `midiPitch` 不同且在和弦模式下，则添加到和弦。
    *   插入后，小节内的 `notes` 列表将根据 `startTimeInMeasure` 重新排序。
*   **插入和弦 (`addChord`)**：
    *   当用户在多音模式下选择多个音符后点击“确认”时，UI层将调用 `addChord(trackId, measureId, startTime, midiPitches, durationType, ...)`。
    *   `SheetMusicManager` 将在指定轨道和小节内，根据 `startTime` 插入多个音符，这些音符共享相同的 `startTimeInMeasure`，形成一个和弦。
    *   同样，插入后小节内的 `notes` 列表将重新排序。

**插入位置的确定**：

1.  **UI 层的“插入区域”**：
    *   在 `_buildNotesGrid` 和 `_buildInsertArea` 中，UI会根据当前音符的时值来计算下一个可能的插入点 (`nextBeatIndex`)，并显示可点击的插入区域。
    *   当用户点击某个插入区域时，`SheetEditorController` 会更新 `selectedMeasureIndex` 和 `selectedBeatIndex` (或直接 `insertTimeInMeasure`)。
    *   在 `SheetMusicManager` 中 `addNote` 时，`startTime` 参数就是这个 `insertTimeInMeasure`。
2.  **小节开始**：
    *   如果小节为空，用户点击小节空白处，`insertTimeInMeasure` 默认为 0。

**关键点**：
*   所有插入操作都会更新 `_currentSheetMusic`，并通过响应式流通知UI更新。
*   插入操作后，通常会选中新插入的乐符或和弦中的第一个乐符。

#### 5.5.4. 跨小节、多选、和弦处理细节

*   **跨小节操作**：
    *   目前设计的 `SheetMusicManager` 的 `deleteNotes` 和 `updateNote` 方法接收 `trackId`, `measureId`, `noteId` 作为参数，可以精确操作任何位置的音符。
    *   范围选择 (如果实现) 将需要在 `SheetMusicManager` 内部遍历多个小节来识别选中的乐符。
*   **多选操作**：
    *   `_multiSelectedNotes` 列表用于存储所有被多选的乐符的 `SelectedNote` 对象。
    *   `deleteNotes` 方法可以接收一个 `List<String> noteIdsToDelete`，从而一次性删除多个乐符，无论它们是否在同一个小节或轨道。
*   **和弦处理**：
    *   在数据结构层面，和弦表示为多个 `Note` 对象具有相同的 `startTimeInMeasure`。
    *   在 `addChord` 方法中，`SheetMusicManager` 会创建多个 `Note` 对象并插入到指定小节。
    *   在UI渲染时，当遍历小节的音符列表时，如果发现多个音符的 `startTimeInMeasure` 相同，UI可以将其渲染为一个和弦的视觉效果。

通过这些细致的设计，乐符的选择、删除和插入将变得更加健壮和可预测，同时更好地支持复杂的用户操作。

### 5.6. 撤销/重做机制

撤销/重做功能对于编辑类应用至关重要。我们将采用“命令模式”的变体，通过保存乐谱的“状态快照”来实现。

#### 5.6.1. 核心思想：状态快照与历史栈

*   **状态快照**：每次执行对乐谱数据产生修改的操作时，我们都会获取当前 `SheetMusic` 对象的深度拷贝，作为乐谱的一个“状态快照”。
*   **历史栈**：这些状态快照将被存储在一个历史记录列表中 (`_history`)。我们还会维护一个指向当前状态的索引 (`_historyIndex`)。

#### 5.6.2. `SheetMusicManager` 中的实现

在 `SheetMusicManager` 中，我们已经初步实现了撤销/重做的逻辑：

*   **`_history` (List<SheetMusic>)**：一个存储 `SheetMusic` 状态快照的列表。
*   **`_historyIndex` (int)**：当前乐谱状态在 `_history` 中的索引。
*   **`_executeCommand(VoidCallback command)`**：
    *   这是所有修改乐谱数据的方法（例如 `addNote`, `deleteNotes`, `updateSheetTitle` 等）都应该调用的一个包装函数。
    *   在执行 `command()` 之前，它会处理历史记录的分支。如果当前不在历史栈的末尾（即用户执行了撤销操作后又执行了新的操作），则会丢弃当前 `_historyIndex` 之后的所有历史记录。
    *   执行 `command()` 后，它会调用 `_saveCurrentStateToHistory()`。
*   **`_saveCurrentStateToHistory()`**：
    *   获取 `_currentSheetMusic.value` 的深度拷贝。
    *   将拷贝后的状态添加到 `_history` 列表的末尾。
    *   更新 `_historyIndex` 指向新的末尾。
    *   调用 `_updateUndoRedoStatus()` 更新撤销/重做按钮的状态。
*   **`undo()`**：
    *   如果 `_canUndo.value` 为 `true`，则将 `_historyIndex` 减1。
    *   将 `_currentSheetMusic.value` 更新为 `_history[_historyIndex]` 的深度拷贝。
    *   更新撤销/重做按钮的状态，并清除所有选中状态。
*   **`redo()`**：
    *   如果 `_canRedo.value` 为 `true`，则将 `_historyIndex` 加1。
    *   将 `_currentSheetMusic.value` 更新为 `_history[_historyIndex]` 的深度拷贝。
    *   更新撤销/重做按钮的状态，并清除所有选中状态。
*   **`_deepCopySheetMusic(SheetMusic original)`**：
    *   这是一个关键的辅助方法，用于递归地深度拷贝 `SheetMusic` 对象及其所有嵌套的 `Track`, `Measure`, `Note` 实例。这是为了确保历史记录中的每个状态都是独立的，修改当前状态不会影响历史状态。

#### 5.6.3. 优化与考量

*   **性能**：
    *   每次操作都进行深度拷贝可能会带来性能开销，特别是对于非常大的乐谱。
    *   **优化方向**：
        *   **增量状态存储**：只存储每次操作的“差异”或“逆操作”，而不是整个乐谱的快照。这需要更复杂的命令模式实现，每个命令都知道如何撤销和重做自己。对于当前需求，全状态快照足够，后续可根据性能瓶颈进行优化。
        *   **限制历史记录大小**：可以设置 `_history` 列表的最大长度，当超出限制时，移除最旧的记录。
*   **内存**：
    *   同样，存储大量状态快照会占用较多内存。
    *   **优化方向**：
        *   与性能优化类似，考虑增量存储。
        *   在不活跃的乐谱上，可以考虑释放部分历史记录。
*   **UI反馈**：
    *   `_canUndo` 和 `_canRedo` 响应式变量将直接控制UI层撤销/重做按钮的启用/禁用状态，提供良好的用户体验。
    *   撤销/重做操作后，清除当前选中状态，避免出现选中状态与乐谱不一致的情况。
*   **初始化**：
    *   在加载或创建新乐谱时，需要清空旧的历史记录 (`_clearHistory()`)，并将新乐谱的初始状态保存到历史中 (`_saveCurrentStateToHistory()`)。

通过上述设计，撤销/重做功能可以在 `SheetMusicManager` 领域层得到统一且健壮的实现，UI层只需简单地触发 `undo()` 或 `redo()` 方法即可。

## 6. 总结与展望

本设计文档提出了乐谱编辑页面重构的详细方案。通过引入清晰的领域模型、强化的三层架构和中心化的 `SheetMusicManager` 服务，我们旨在彻底解决当前乐谱编辑中存在的混乱问题，实现UI与数据的高度解耦，并提升系统的可维护性、可扩展性和用户体验。

下一步，我们将根据此设计文档，逐步进行代码实现。在实现过程中，我们将密切关注性能和内存使用，并根据实际情况进行必要的调整和优化。

