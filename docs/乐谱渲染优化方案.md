# 乐谱渲染优化方案

## 概述

本文档记录了针对手机端乐谱渲染的系统性优化方案，主要解决密集音符（8分、16分音符）在小屏设备上重叠、拥挤、难以辨认的问题。

## 问题背景

### 原始问题
- **简谱问题**：密集的8分/16分音符在手机端粘在一起，无法辨认
- **五线谱问题**：符头太大，音符挨得近时视觉模糊
- **附点问题**：附点距离数字太远，与其他数字重叠
- **间距问题**：所有音符均匀分布，不符合音乐节奏感

### 优化目标
1. **解决重叠**：确保音符不会相互重叠
2. **提高可读性**：清晰辨认每个音符
3. **符合乐理**：间距体现节奏分组
4. **保持一致性**：相同类型音符视觉间距一致
5. **适配屏幕**：支持不同屏幕尺寸

## 优化方案架构

### 三层设计原则

```
第一层：布局结构
  └─ 根据密度模式和屏幕宽度决定每行小节数

第二层：空间分配
  └─ 在每行内均匀分配小节宽度
  └─ 在每小节内均匀分配拍宽度

第三层：音符定位（核心优化）
  ├─ 符号尺寸：根据密度模式和音符密度动态调整
  ├─ 分组间距：根据符杠组和附点关系智能分配
  └─ 附点位置：紧贴数字右侧，避免重叠
```

## 详细设计

### 1. 密度模式系统

引入 `NoteDensityMode` 枚举，统一控制所有渲染参数：

```dart
enum NoteDensityMode {
  compact,      // 紧凑模式（桌面大屏）
  comfortable,  // 舒适模式（默认，平板）
  spacious,     // 宽松模式（手机端）
}
```

#### 各模式参数对比

| 参数 | Compact | Comfortable | Spacious |
|------|---------|-------------|----------|
| **简谱字号** | 20 | 18 | 17 |
| **五线谱符头** | 38 | 34 | 32 |
| **符干长度** | 35 | 33 | 32 |
| **符杠间距** | 8px | 7px | 7px |
| **每行小节数** | 6 | 5 | 4 |
| **最小音符间距** | 25px | 32px | 40px |

### 2. 符号尺寸优化

#### 2.1 基础尺寸缩小

**简谱：**
- Comfortable: 20 → 18（减少10%）
- Spacious: 20 → 17（减少15%）

**五线谱：**
- Comfortable: 38 → 34（减少10.5%）
- Spacious: 38 → 32（减少15.8%）

#### 2.2 密集拍动态缩小

检测一拍内音符数量，超过阈值进一步缩小：

```dart
// 密集拍阈值：6个音符
if (noteCount > denseNoteThreshold) {
  // 简谱再缩小1号
  fontSize = baseFontSize - denseBeatFontSizeReduction;
  // comfortable: 18→17, spacious: 17→16

  // 五线谱再缩小2号
  noteHeadSize = baseSize - denseBeatNoteHeadFontSizeReduction;
  // comfortable: 34→32, spacious: 32→30
}
```

**效果：**
- 普通曲谱：保持较大字号（易读）
- 复杂曲谱：自动缩小（防重叠）

### 3. 智能分组间距（核心创新）

#### 3.1 设计思路

**音乐理论依据：**
- 符杠连接的音符应视觉上形成一组
- 附点音符与后续短音符构成节奏型
- 不同组之间应有明显间隔

**间距分类：**

| 间距类型 | Comfortable | Spacious | 应用场景 |
|---------|-------------|----------|----------|
| **组内间距** | 10px | 12px | 符杠组、附点组内部 |
| **组间间距** | 24px | 28px | 不同组之间 |
| **独立间距** | 20px | 24px | 单独的长音符 |

#### 3.2 分组规则

```dart
// 规则1：在同一符杠组
if (prevBeamGroup == currBeamGroup && prevBeamGroup != -1) {
  spacing = groupInnerSpacing;  // 10px，紧凑
}

// 规则2：前一个有附点 && 当前是短音符
else if (prev.dots > 0 && curr.isShortNote) {
  spacing = groupInnerSpacing;  // 10px，紧凑
}

// 规则3：不同组
else {
  spacing = groupOuterSpacing;  // 24px，宽松
}
```

#### 3.3 效果示例

**示例1：8个16分音符（2组×4音符）**

```
之前（均匀分布）：
1___2___3___4___5___6___7___8
每个16px，总宽：112px

优化后（分组）：
[1 2 3 4]       [5 6 7 8]
组内10px        组间24px
总宽：3×10 + 24 + 3×10 = 84px
节省：25%
```

**示例2：附点八分 + 十六分（经典节奏）**

```
之前：
♪._____________♬
间距16px，看起来分离

优化后：
[♪. ♬]
间距10px，视觉上是一组
```

**示例3：混合节奏**

```
♩  [♪. ♬]  [♪ ♪]
正常  紧凑组  紧凑组
20px  10px  24px  10px
```

### 4. 附点位置优化

#### 4.1 问题分析

```dart
// 旧代码问题
x + fontSize * 0.6  // 固定比例，不考虑数字实际宽度

问题：
- 数字"1"窄，"8"宽，附点位置不一致
- 附点距离过远，与后面数字重叠
```

#### 4.2 解决方案

```dart
// 新代码：基于实际宽度
final numberWidth = textPainter.width;
final dotStartX = x + numberWidth / 2 + 2;

优点：
- 紧贴数字右边缘
- 固定2px小间距
- 不会与其他数字重叠
```

**视觉效果：**

```
之前：2      ·      3  (附点与3重叠)
现在：2·   3           (清晰可辨)
```

### 5. 实现细节

#### 5.1 简谱实现（jianpu_painter.dart）

**关键代码：**

```dart
// 1. 计算每个音符的位置
final positions = <double>[];
double currentX = 0;

for (var i = 0; i < noteCount; i++) {
  if (i == 0) {
    positions.add(0);
  } else {
    // 查找符杠组
    final prevBeamGroup = getPreviousBeamGroup();
    final currBeamGroup = getCurrentBeamGroup();

    // 判断间距类型
    double spacing;
    if (inSameBeamGroup) {
      spacing = config.jianpuGroupInnerSpacing;
    } else if (isDotGroup) {
      spacing = config.jianpuGroupInnerSpacing;
    } else {
      spacing = config.jianpuGroupOuterSpacing;
    }

    currentX += spacing;
    positions.add(currentX);
  }
}

// 2. 居中布局
final totalWidth = positions.last;
final startX = beatX - totalWidth / 2;

// 3. 绘制音符
for (var i = 0; i < noteCount; i++) {
  final noteX = startX + positions[i];
  drawNote(noteX, ...);
}
```

#### 5.2 五线谱实现（layout_engine.dart）

**关键代码：**

```dart
// 在布局阶段应用分组间距
for (var i = 0; i < notesInBeat.length; i++) {
  if (i == 0) {
    positions.add(0);
  } else {
    final prevNote = notesInBeat[i - 1].note;
    final currNote = notesInBeat[i].note;

    // 判断是否都是短音符（会被符杠连接）
    final bothShortNotes = prevNote.duration.beamCount > 0 &&
                          currNote.duration.beamCount > 0;

    double spacing;
    if (bothShortNotes) {
      spacing = config.minNoteSpacing * 0.3;  // 紧凑
    } else if (prevNote.dots > 0 && currNote.isShortNote) {
      spacing = config.minNoteSpacing * 0.3;  // 紧凑
    } else {
      spacing = config.minNoteSpacing * 0.8;  // 正常
    }

    currentX += spacing;
    positions.add(currentX);
  }
}
```

## 优化效果总结

### 空间效率

| 场景 | 优化前 | 优化后 | 节省 |
|------|--------|--------|------|
| 8个16分音符 | 112px | 84px | 25% |
| 4个8分音符 | 48px | 44px | 8% |
| 附点+短音符×4 | 48px | 34px | 29% |

### 可读性提升

**符号尺寸：**
- ✅ 减少10-15%，不再重叠
- ✅ 密集拍自动缩小，防止极端情况
- ✅ 字号仍在可读范围（16-18号）

**间距清晰：**
- ✅ 分组明确，节奏感强
- ✅ 符合音乐理论和演奏习惯
- ✅ 相同类型音符间距一致

**附点精准：**
- ✅ 紧贴数字，不会重叠
- ✅ 视觉上形成整体

### 适配性

**屏幕适配：**
- Comfortable（默认）：适合平板、小笔记本（7-10寸）
- Spacious：适合手机（5-6寸）
- Compact：适合桌面大屏（>13寸）

**音符密度适配：**
- 简单曲谱：保持大字号，易读
- 复杂曲谱：自动缩小，防重叠
- 极端密集：提供降级方案

## 使用指南

### 默认配置

```dart
// 自动使用 Comfortable 模式
RenderConfig _config = const RenderConfig();
```

### 手机端优化

```dart
// 手动切换到 Spacious 模式
RenderConfig _config = const RenderConfig(
  densityMode: NoteDensityMode.spacious,
);
```

### 响应式配置

```dart
// 根据屏幕宽度自动选择
final screenWidth = MediaQuery.of(context).size.width;
final densityMode = screenWidth < 600
    ? NoteDensityMode.spacious      // 手机
    : NoteDensityMode.comfortable;  // 平板/电脑

_config = RenderConfig(densityMode: densityMode);
```

## 技术亮点

### 1. 统一配置系统

通过单一 `NoteDensityMode` 参数控制所有渲染细节：
- 符号尺寸
- 间距参数
- 布局密度

**优点：**
- 简化使用：用户只需选择一个模式
- 一致性强：所有参数协调工作
- 易于维护：修改一处，全局生效

### 2. 智能分组间距

基于音乐理论的间距分配：
- 符杠组识别
- 附点关系判断
- 三级间距系统

**优点：**
- 节省空间：密集音符节省20-30%
- 提高可读性：节奏分组清晰
- 符合习惯：传统乐谱排版规则

### 3. 动态自适应

多层次的动态调整：
- 密度模式自适应
- 音符密度自适应
- 实际宽度计算

**优点：**
- 灵活性强：适应各种场景
- 鲁棒性好：极端情况有降级
- 用户体验佳：自动优化

## 后续优化方向

### 短期优化

1. **五线谱符杠优化**
   - 当前符杠连接逻辑需要优化
   - 全8分音符小节的分组问题
   - 符杠断点判断

2. **三连音处理**
   - 识别三连音标记
   - 应用特殊分组间距

3. **性能优化**
   - 缓存布局计算结果
   - 减少重复绘制

### 长期优化

1. **用户自定义**
   - 间距微调滑块
   - 字号选择器
   - 预设方案

2. **智能推荐**
   - 根据曲谱复杂度自动推荐模式
   - 设备类型检测

3. **高级排版**
   - 跨小节符杠
   - 复杂节奏型识别
   - 多声部优化

## 参考资料

### 音乐排版规范
- Gould, E. (2011). *Behind Bars: The Definitive Guide to Music Notation*
- Read, G. (1979). *Music Notation: A Manual of Modern Practice*

### 实现参考
- SMuFL (Standard Music Font Layout)
- LilyPond 乐谱排版引擎
- MuseScore 开源乐谱软件

## 更新日志

### v1.0 (2026-01-21)
- ✅ 实现密度模式系统
- ✅ 符号尺寸优化（基础+动态）
- ✅ 智能分组间距（简谱+五线谱）
- ✅ 附点位置优化
- ✅ 创建设计文档

### 待完成
- ⏳ 五线谱符杠分组优化
- ⏳ 三连音特殊处理
- ⏳ 性能优化

---

**文档版本：** 1.0
**最后更新：** 2026-01-21
**维护者：** 乐理通开发团队
