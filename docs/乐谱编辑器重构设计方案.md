# 乐谱编辑器重构设计方案

## 1. 问题分析

### 1.1 当前架构的问题

#### 数据结构问题
当前的数据模型 `Score → Track → Measure → Beat → Note` 存在以下问题：

1. **嵌套过深**：从选中音符到修改需要层层深入
2. **索引混乱**：
   - `selectedMeasureIndex` - 小节索引
   - `selectedBeatIndex` - 拍索引（double类型，支持8分音符）
   - `selectedNoteIndex` - beat内音符索引
   - `selectedJianpuNoteIndex` - 简谱显示索引
3. **状态分散**：
   - 左右手使用不同的轨道（Track）
   - 每个轨道单独维护小节索引
   - 切换轨道时需要保存/恢复状态
4. **不可变数据结构的代价**：
   - 每次修改都需要复制整个数据链：`Score → Track → Measure → Beat → Note`
   - 修改一个音符需要创建6-7个新对象

#### 操作逻辑问题

```dart
// 当前的addNote实现（285-374行）
void addNote(int pitch, {String? lyric}) {
  // 1. 获取score
  // 2. 获取track
  // 3. 获取measure
  // 4. 找到或创建beat
  // 5. 添加note到beat
  // 6. 更新beat
  // 7. 更新measure
  // 8. 更新track
  // 9. 更新score
  // 共9步，创建5-6个新对象
}
```

**问题：**
- 删除音符时索引计算错误（426-486行）
- 选中音符后删除可能删错位置
- `selectedJianpuNoteIndex` 和 `selectedNoteIndex` 不同步
- 多轨道编辑时状态管理复杂

### 1.2 具体场景问题

#### 场景1：删除音符
```
问题：selectedNoteIndex 是beat内的索引，但简谱视图是连续的
当前：删除第5个音符，需要先找到对应的beat，再找到beat内的索引
混乱：如果beat内有多个音符（和弦），索引容易错位
```

#### 场景2：插入音符
```
问题：需要手动计算beatIndex，还要处理小节满了的情况
当前：如果小节满了，自动跳到下一小节或创建新小节
混乱：自动创建小节时，左右手的小节数可能不一致
```

#### 场景3：切换轨道
```
问题：需要保存当前轨道的位置，恢复目标轨道的位置
当前：使用Map<int, int>保存每个轨道的索引
混乱：小节数不同时，恢复的索引可能无效
```

---

## 2. 重构设计方案

### 2.1 核心思想

1. **数据与操作解耦**：数据模型保持不变，创建操作层
2. **引入文档模型（Document Model）**：类似文本编辑器的方式
3. **位置抽象（Position）**：统一的位置表示
4. **命令模式（Command Pattern）**：支持撤销/重做

### 2.2 新架构设计

```
┌─────────────────────────────────────┐
│         UI Layer (Widget)           │
│  - ProfessionalJianpuEditor         │
│  - SheetEditorPage                  │
└───────────────┬─────────────────────┘
                │
                ↓
┌─────────────────────────────────────┐
│      Controller Layer               │
│  - SheetEditorController            │
│    (保持API不变，内部使用Document)  │
└───────────────┬─────────────────────┘
                │
                ↓
┌─────────────────────────────────────┐
│      Document Layer (NEW)           │
│  - ScoreDocument                    │
│    ├─ TrackDocument                 │
│    ├─ Position                      │
│    ├─ Selection                     │
│    └─ CommandManager                │
└───────────────┬─────────────────────┘
                │
                ↓
┌─────────────────────────────────────┐
│      Data Model Layer               │
│  - Score, Track, Measure, Beat, Note│
│    (保持不变)                        │
└─────────────────────────────────────┘
```

---

## 3. 核心类设计

### 3.1 Position - 统一的位置表示

```dart
/// 乐谱中的位置
/// 唯一标识一个音符的位置
class Position {
  /// 轨道索引（0=右手，1=左手）
  final int trackIndex;

  /// 小节索引（从0开始）
  final int measureIndex;

  /// 拍索引（从0开始，整数）
  final int beatIndex;

  /// beat内音符索引（从0开始）
  /// 如果是-1，表示指向beat的位置（用于插入）
  final int noteIndex;

  const Position({
    required this.trackIndex,
    required this.measureIndex,
    required this.beatIndex,
    this.noteIndex = -1,
  });

  /// 是否指向一个具体的音符
  bool get pointsToNote => noteIndex >= 0;

  /// 是否指向一个beat位置
  bool get pointsToBeat => noteIndex < 0;

  /// 创建指向下一个音符的位置
  Position nextNote();

  /// 创建指向上一个音符的位置
  Position previousNote();

  /// 比较两个位置（用于选区）
  int compareTo(Position other);

  @override
  bool operator ==(Object other);

  @override
  int get hashCode;
}
```

**优势：**
- 统一的位置表示，不再有4个不同的索引
- 支持相对导航（nextNote, previousNote）
- 支持比较（用于选区）
- 独立于数据模型，方便测试

### 3.2 Selection - 选区管理

```dart
/// 选区
/// 可以是单个音符，也可以是多个音符范围
class Selection {
  /// 起始位置
  final Position start;

  /// 结束位置（如果为null，表示单点选择）
  final Position? end;

  const Selection(this.start, [this.end]);

  /// 是否为单点选择
  bool get isSinglePoint => end == null;

  /// 是否为范围选择
  bool get isRange => end != null;

  /// 是否包含某个位置
  bool contains(Position position);

  /// 获取选区内所有音符的位置
  List<Position> getAllPositions(ScoreDocument document);

  /// 移动选区（用于方向键导航）
  Selection moveUp/Down/Left/Right(ScoreDocument document);
}
```

### 3.3 TrackDocument - 单轨道文档

```dart
/// 单个轨道的文档模型
/// 提供对Track数据的封装和操作
class TrackDocument {
  /// 原始Track数据
  final Track _track;

  /// 元数据（时间签名等）
  final ScoreMetadata _metadata;

  TrackDocument(this._track, this._metadata);

  // =========== 查询操作 ===========

  /// 获取指定位置的音符（如果存在）
  Note? getNoteAt(Position position);

  /// 获取指定小节的所有音符（按时间顺序）
  List<Note> getNotesInMeasure(int measureIndex);

  /// 获取指定范围的所有音符
  List<Note> getNotesInRange(Position start, Position end);

  /// 检查位置是否有效
  bool isValidPosition(Position position);

  /// 将简谱索引转换为Position
  /// 这样可以统一处理简谱和五线谱的选择
  Position? positionFromSequentialIndex(int measureIndex, int sequentialNoteIndex);

  /// 将Position转换为简谱索引
  int? sequentialIndexFromPosition(Position position);

  // =========== 修改操作（返回新的Track） ===========

  /// 在指定位置插入音符
  Track insertNote(Position position, Note note);

  /// 删除指定位置的音符
  Track deleteNote(Position position);

  /// 修改指定位置的音符
  Track updateNote(Position position, Note newNote);

  /// 在指定位置插入和弦（多个音符）
  Track insertChord(Position position, List<Note> notes);

  // =========== 小节操作 ===========

  /// 在指定索引插入空小节
  Track insertMeasure(int measureIndex);

  /// 删除指定小节
  Track deleteMeasure(int measureIndex);

  // =========== 导航操作 ===========

  /// 获取下一个有音符的位置
  Position? nextNotePosition(Position current);

  /// 获取上一个有音符的位置
  Position? previousNotePosition(Position current);

  /// 获取小节的第一个音符位置
  Position? firstNoteInMeasure(int measureIndex);

  /// 获取小节的最后一个音符位置
  Position? lastNoteInMeasure(int measureIndex);

  // =========== 时间计算 ===========

  /// 计算指定位置在小节内的时间偏移（以拍为单位）
  double getTimeOffsetInMeasure(Position position);

  /// 根据时间偏移查找Position
  Position? positionFromTimeOffset(int measureIndex, double offset);

  /// 检查小节是否已满
  bool isMeasureFull(int measureIndex);
}
```

**关键特点：**
- 封装了所有对单个Track的操作
- 所有修改操作返回新的Track（保持不可变性）
- 提供位置转换（Position ↔ 简谱索引）
- 提供时间计算（支持精确定位）

### 3.4 ScoreDocument - 总谱文档

```dart
/// 乐谱文档
/// 管理整个Score的编辑状态和操作
class ScoreDocument {
  /// 原始Score数据
  Score _score;

  /// 每个轨道的文档（缓存）
  final Map<int, TrackDocument> _trackDocuments = {};

  /// 当前选区
  Selection _selection;

  /// 命令管理器（撤销/重做）
  final CommandManager _commandManager = CommandManager();

  ScoreDocument(this._score, {Position? initialPosition})
    : _selection = Selection(initialPosition ?? const Position(
        trackIndex: 0,
        measureIndex: 0,
        beatIndex: 0,
        noteIndex: -1,
      ));

  // =========== 访问器 ===========

  /// 获取当前Score
  Score get score => _score;

  /// 获取当前选区
  Selection get selection => _selection;

  /// 获取指定轨道的文档
  TrackDocument getTrack(int trackIndex);

  /// 获取当前轨道的文档
  TrackDocument get currentTrack => getTrack(_selection.start.trackIndex);

  // =========== 选择操作 ===========

  /// 设置选区
  void setSelection(Selection selection);

  /// 移动选区到指定位置
  void moveSelectionTo(Position position);

  /// 扩展选区（Shift+方向键）
  void extendSelection(Position newEnd);

  /// 清除选区（回到单点选择）
  void clearSelection();

  // =========== 编辑操作（通过Command） ===========

  /// 插入音符
  void insertNote(Note note, {Position? at});

  /// 删除选中的内容
  void deleteSelection();

  /// 修改选中音符的属性
  void updateSelectedNote({
    int? pitch,
    NoteDuration? duration,
    Accidental? accidental,
    bool? isDotted,
    String? lyric,
  });

  /// 插入和弦
  void insertChord(List<Note> notes, {Position? at});

  /// 插入小节
  void insertMeasure({int? at});

  /// 删除小节
  void deleteMeasure(int measureIndex);

  // =========== 撤销/重做 ===========

  /// 撤销
  void undo();

  /// 重做
  void redo();

  /// 是否可以撤销
  bool get canUndo => _commandManager.canUndo;

  /// 是否可以重做
  bool get canRedo => _commandManager.canRedo;

  // =========== 导航操作 ===========

  /// 移动到下一个音符
  void moveToNextNote();

  /// 移动到上一个音符
  void moveToPreviousNote();

  /// 移动到下一小节
  void moveToNextMeasure();

  /// 移动到上一小节
  void moveToPreviousMeasure();

  /// 切换轨道
  void switchTrack();

  // =========== 查询操作 ===========

  /// 获取当前选中的音符
  Note? getSelectedNote();

  /// 获取当前位置
  Position get currentPosition => _selection.start;

  /// 检查位置是否有效
  bool isValidPosition(Position position);

  // =========== 内部辅助方法 ===========

  /// 执行命令（自动记录到撤销栈）
  void _executeCommand(EditCommand command);

  /// 更新Score（自动刷新缓存）
  void _updateScore(Score newScore);

  /// 刷新轨道文档缓存
  void _refreshTrackDocument(int trackIndex);
}
```

**关键特点：**
- 统一的入口，隐藏复杂的数据操作
- 自动管理撤销/重做
- 提供导航操作，简化UI层代码
- 缓存TrackDocument，提高性能

### 3.5 Command Pattern - 命令模式

```dart
/// 编辑命令接口
abstract class EditCommand {
  /// 执行命令
  Score execute(Score currentScore);

  /// 撤销命令
  Score undo(Score currentScore);

  /// 命令描述（用于调试）
  String get description;
}

/// 插入音符命令
class InsertNoteCommand implements EditCommand {
  final Position position;
  final Note note;

  InsertNoteCommand(this.position, this.note);

  @override
  Score execute(Score currentScore) {
    final trackDoc = TrackDocument(
      currentScore.tracks[position.trackIndex],
      currentScore.metadata,
    );
    final newTrack = trackDoc.insertNote(position, note);
    return _updateTrack(currentScore, position.trackIndex, newTrack);
  }

  @override
  Score undo(Score currentScore) {
    final trackDoc = TrackDocument(
      currentScore.tracks[position.trackIndex],
      currentScore.metadata,
    );
    final newTrack = trackDoc.deleteNote(position);
    return _updateTrack(currentScore, position.trackIndex, newTrack);
  }

  @override
  String get description => 'Insert note at $position';

  Score _updateTrack(Score score, int trackIndex, Track newTrack) {
    final tracks = List<Track>.from(score.tracks);
    tracks[trackIndex] = newTrack;
    return score.copyWith(tracks: tracks);
  }
}

/// 删除音符命令
class DeleteNoteCommand implements EditCommand {
  final Position position;
  Note? _deletedNote; // 保存被删除的音符，用于撤销

  DeleteNoteCommand(this.position);

  @override
  Score execute(Score currentScore) {
    final trackDoc = TrackDocument(
      currentScore.tracks[position.trackIndex],
      currentScore.metadata,
    );
    _deletedNote = trackDoc.getNoteAt(position);
    final newTrack = trackDoc.deleteNote(position);
    return _updateTrack(currentScore, position.trackIndex, newTrack);
  }

  @override
  Score undo(Score currentScore) {
    if (_deletedNote == null) return currentScore;
    final trackDoc = TrackDocument(
      currentScore.tracks[position.trackIndex],
      currentScore.metadata,
    );
    final newTrack = trackDoc.insertNote(position, _deletedNote!);
    return _updateTrack(currentScore, position.trackIndex, newTrack);
  }

  @override
  String get description => 'Delete note at $position';

  Score _updateTrack(Score score, int trackIndex, Track newTrack) {
    final tracks = List<Track>.from(score.tracks);
    tracks[trackIndex] = newTrack;
    return score.copyWith(tracks: tracks);
  }
}

/// 命令管理器
class CommandManager {
  final List<EditCommand> _undoStack = [];
  final List<EditCommand> _redoStack = [];
  static const int maxUndoSteps = 50;

  /// 执行命令
  Score execute(EditCommand command, Score currentScore) {
    final newScore = command.execute(currentScore);
    _undoStack.add(command);
    if (_undoStack.length > maxUndoSteps) {
      _undoStack.removeAt(0);
    }
    _redoStack.clear();
    return newScore;
  }

  /// 撤销
  Score? undo(Score currentScore) {
    if (_undoStack.isEmpty) return null;
    final command = _undoStack.removeLast();
    _redoStack.add(command);
    return command.undo(currentScore);
  }

  /// 重做
  Score? redo(Score currentScore) {
    if (_redoStack.isEmpty) return null;
    final command = _redoStack.removeLast();
    _undoStack.add(command);
    return command.execute(currentScore);
  }

  bool get canUndo => _undoStack.isNotEmpty;
  bool get canRedo => _redoStack.isNotEmpty;

  void clear() {
    _undoStack.clear();
    _redoStack.clear();
  }
}
```

---

## 4. Controller 重构

### 4.1 保持API兼容

```dart
/// SheetEditorController（重构后）
class SheetEditorController extends GetxController {
  // =========== 内部状态（使用Document） ===========

  /// 文档模型（核心）
  ScoreDocument? _document;

  /// 当前Score（响应式，从document同步）
  final currentScore = Rxn<Score>();

  // =========== 公开API（保持不变） ===========

  /// 加载乐谱
  void loadScore(Score score) {
    _document = ScoreDocument(score);
    currentScore.value = score;
    // ... 其他初始化
  }

  /// 添加音符（简化实现）
  void addNote(int pitch, {String? lyric}) {
    if (_document == null) return;

    final note = Note(
      pitch: pitch,
      duration: selectedDuration.value.duration,
      accidental: selectedAccidental.value,
      dots: isDotted.value ? 1 : 0,
      lyric: lyric,
    );

    // 只需一行！
    _document!.insertNote(note);

    // 同步到响应式变量
    currentScore.value = _document!.score;

    // 自动移动到下一个位置
    _document!.moveToNextNote();
  }

  /// 删除选中音符（简化实现）
  void deleteSelectedNote() {
    if (_document == null) return;

    // 只需一行！
    _document!.deleteSelection();

    // 同步
    currentScore.value = _document!.score;
  }

  /// 选择音符（简化实现）
  void selectNote(int measureIndex, int beatIndex, int noteIndex) {
    if (_document == null) return;

    // 创建Position
    final position = Position(
      trackIndex: selectedTrackIndex.value,
      measureIndex: measureIndex,
      beatIndex: beatIndex,
      noteIndex: noteIndex,
    );

    // 移动选区
    _document!.moveSelectionTo(position);

    // 更新UI状态
    _syncUIState();
  }

  // =========== 私有辅助方法 ===========

  /// 同步UI状态（从Document到Observable变量）
  void _syncUIState() {
    if (_document == null) return;

    final position = _document!.currentPosition;
    selectedTrackIndex.value = position.trackIndex;
    selectedMeasureIndexRx.value = position.measureIndex;
    selectedNoteIndex.value = position.noteIndex;

    // 计算简谱索引
    final trackDoc = _document!.currentTrack;
    final seqIndex = trackDoc.sequentialIndexFromPosition(position);
    selectedJianpuNoteIndex.value = seqIndex ?? -1;
  }

  // =========== 其他API保持不变 ===========
}
```

**优势：**
- Controller的公开API保持不变，不影响UI代码
- 内部实现大幅简化，从9步变成1步
- 自动处理撤销/重做
- 索引计算由Document负责，不会出错

---

## 5. 实施步骤

### 5.1 第一阶段：创建新类（不破坏现有代码）

1. 创建 `lib/features/tools/sheet_music/models/position.dart`
2. 创建 `lib/features/tools/sheet_music/models/selection.dart`
3. 创建 `lib/features/tools/sheet_music/document/track_document.dart`
4. 创建 `lib/features/tools/sheet_music/document/score_document.dart`
5. 创建 `lib/features/tools/sheet_music/commands/edit_command.dart`
6. 创建 `lib/features/tools/sheet_music/commands/command_manager.dart`

### 5.2 第二阶段：编写单元测试

```dart
// test/features/tools/sheet_music/document/track_document_test.dart
void main() {
  group('TrackDocument', () {
    test('insertNote should add note at correct position', () {
      // 准备数据
      final track = Track(...);
      final doc = TrackDocument(track, metadata);
      final position = Position(trackIndex: 0, measureIndex: 0, beatIndex: 0);
      final note = Note(pitch: 60);

      // 执行操作
      final newTrack = doc.insertNote(position, note);

      // 验证结果
      expect(newTrack.measures[0].beats.length, 1);
      expect(newTrack.measures[0].beats[0].notes[0].pitch, 60);
    });

    test('deleteNote should remove note at correct position', () {
      // ... 类似的测试
    });

    test('positionFromSequentialIndex should convert correctly', () {
      // ... 测试索引转换
    });
  });
}
```

### 5.3 第三阶段：重构Controller

1. 在Controller中添加 `_document` 字段
2. 逐个方法替换实现（保持API不变）
3. 删除冗余的索引管理代码
4. 测试功能是否正常

### 5.4 第四阶段：清理和优化

1. 删除不再需要的辅助方法
2. 更新文档注释
3. 性能优化（如果需要）
4. 添加更多单元测试

---

## 6. 示例对比

### 6.1 插入音符

#### 重构前（9步）
```dart
void addNote(int pitch, {String? lyric}) {
  final score = currentScore.value;
  if (score == null) return;

  final trackIndex = selectedTrackIndex.value;
  final track = score.tracks[trackIndex];
  var measureIndex = selectedMeasureIndex;
  var measure = track.measures[measureIndex];
  var beatIndex = selectedBeatIndex;

  // ... 检查小节是否已满（10行代码）
  // ... 创建或查找Beat（20行代码）
  // ... 更新所有层级（20行代码）
}
```

#### 重构后（1行）
```dart
void addNote(int pitch, {String? lyric}) {
  if (_document == null) return;
  _document!.insertNote(Note(pitch: pitch, lyric: lyric));
  currentScore.value = _document!.score;
}
```

### 6.2 删除音符

#### 重构前（60行，多个if判断）
```dart
void deleteSelectedNote() {
  // 检查模式
  if (editorMode.value == EditorMode.erase && selectedNoteIndex.value < 0) {
    deleteCurrentMeasure();
    return;
  }

  // 获取所有层级的索引
  final score = currentScore.value;
  final track = score.tracks[trackIndex];
  final measure = track.measures[measureIndex];
  final beatIndex = selectedBeatIndex.floor();
  final beatIdx = measure.beats.indexWhere(...);
  final beat = measure.beats[beatIdx];
  final noteIndex = selectedNoteIndex.value;

  // 验证索引
  if (noteIndex < 0 || noteIndex >= beat.notes.length) {
    selectedNoteIndex.value = -1;
    return;
  }

  // 删除并更新所有层级
  final updatedNotes = List<Note>.from(beat.notes);
  updatedNotes.removeAt(noteIndex);
  final updatedBeats = List<Beat>.from(measure.beats);
  // ... 30行更新代码
}
```

#### 重构后（3行）
```dart
void deleteSelectedNote() {
  if (_document == null) return;
  _document!.deleteSelection();
  currentScore.value = _document!.score;
}
```

### 6.3 选择音符

#### 重构前（需要多个辅助方法）
```dart
void selectNote(int measureIndex, int beatIndex, int noteIndex) {
  // 验证所有索引（20行）
  // 更新多个状态变量（10行）
  // 计算简谱索引（调用_updateJianpuNoteIndex，40行）
}
```

#### 重构后（自动处理）
```dart
void selectNote(int measureIndex, int beatIndex, int noteIndex) {
  if (_document == null) return;
  final position = Position(
    trackIndex: selectedTrackIndex.value,
    measureIndex: measureIndex,
    beatIndex: beatIndex,
    noteIndex: noteIndex,
  );
  _document!.moveSelectionTo(position);
  _syncUIState(); // 自动同步所有UI状态
}
```

---

## 7. 优势总结

### 7.1 代码质量

| 指标 | 重构前 | 重构后 | 改进 |
|-----|--------|--------|------|
| addNote 代码行数 | ~90行 | ~5行 | **-94%** |
| deleteSelectedNote 代码行数 | ~60行 | ~3行 | **-95%** |
| selectNote 复杂度 | 需要多个辅助方法 | 单一方法 | **简化** |
| 索引管理 | 4个不同的索引变量 | 1个Position对象 | **统一** |
| 错误率 | 高（索引容易错位） | 低（类型安全） | **提升** |

### 7.2 可维护性

- **单一职责**：每个类有明确的职责
- **易于测试**：Document和Command可独立测试
- **易于扩展**：新增命令只需实现EditCommand接口
- **易于理解**：Position和Selection概念清晰

### 7.3 性能

- **缓存优化**：TrackDocument缓存，避免重复创建
- **按需计算**：只在需要时计算简谱索引
- **批量操作**：支持批量命令（宏命令）

### 7.4 功能增强

- **完整的撤销/重做**：自动支持所有操作
- **选区操作**：支持多音符选择和批量操作
- **位置导航**：方向键导航更精确
- **协同编辑**：为未来的协同编辑打基础

---

## 8. 风险和注意事项

### 8.1 兼容性

- **保持API兼容**：Controller的公开方法不变
- **渐进式重构**：先添加新代码，再替换旧实现
- **双重实现**：过渡期可以同时支持新旧两种方式

### 8.2 性能

- **内存开销**：Document缓存可能增加内存使用
- **对象创建**：仍然需要创建不可变对象
- **优化方案**：
  - 只缓存当前编辑的轨道
  - 使用WeakReference管理缓存
  - 批量操作时延迟更新UI

### 8.3 学习成本

- **新概念**：团队需要理解Position、Selection等概念
- **文档完善**：需要编写详细的使用文档
- **代码示例**：提供丰富的示例代码

---

## 9. 后续扩展

### 9.1 协同编辑

- Position可以序列化，支持网络传输
- Command可以记录操作日志
- 冲突解决基于Position比较

### 9.2 键盘快捷键

```dart
// 基于Position的快捷键实现
void handleKeyPress(KeyEvent event) {
  if (event.key == LogicalKeyboardKey.delete) {
    _document!.deleteSelection();
  } else if (event.key == LogicalKeyboardKey.arrowRight) {
    _document!.moveToNextNote();
  }
  // ...
}
```

### 9.3 智能输入

- 根据上下文自动调整时值
- 智能补全和弦
- 旋律分析和建议

---

## 10. 结论

这个重构方案：

1. **解决了当前的问题**：
   - 索引混乱 → Position统一表示
   - 操作复杂 → Document封装
   - 状态分散 → Selection管理
   - 撤销难做 → Command模式

2. **不破坏现有功能**：
   - Controller API保持不变
   - UI代码无需修改
   - 数据模型无需改动

3. **提升了代码质量**：
   - 代码量减少90%+
   - 逻辑清晰易懂
   - 易于测试和维护

4. **为未来打基础**：
   - 支持协同编辑
   - 支持高级功能
   - 可扩展性强

**建议：分阶段实施，先创建新类并测试，再逐步替换Controller实现。**
